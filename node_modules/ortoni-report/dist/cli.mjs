#!/usr/bin/env node
import {
  DatabaseManager,
  FileManager,
  HTMLGenerator,
  startReportServer
} from "./chunk-4RZ5C7KY.mjs";

// src/cli.ts
import { program } from "commander";
import * as fs2 from "fs";
import * as path2 from "path";

// src/mergeData.ts
import * as fs from "fs";
import * as path from "path";
async function mergeAllData(options = {}) {
  const folderPath = options.dir || "ortoni-report";
  console.info(`Ortoni Report: Merging shard files in folder: ${folderPath}`);
  if (!fs.existsSync(folderPath)) {
    console.error(`Ortoni Report: folder "${folderPath}" does not exist.`);
    process.exitCode = 1;
    return;
  }
  const filenames = fs.readdirSync(folderPath).filter((f) => f.startsWith("ortoni-shard-") && f.endsWith(".json"));
  if (filenames.length === 0) {
    console.error("Ortoni Report: \u274C No shard files found to merge.");
    process.exitCode = 1;
    return;
  }
  const shardFileIndex = (name) => {
    const m = name.match(/ortoni-shard-(\d+)-of-(\d+)\.json$/);
    return m ? parseInt(m[1], 10) : null;
  };
  const sortedFiles = filenames.map((f) => ({ f, idx: shardFileIndex(f) })).sort((a, b) => {
    if (a.idx === null && b.idx === null) return a.f.localeCompare(b.f);
    if (a.idx === null) return 1;
    if (b.idx === null) return -1;
    return a.idx - b.idx;
  }).map((x) => x.f);
  const allResults = [];
  const projectSet = /* @__PURE__ */ new Set();
  let totalDurationSum = 0;
  let mergedUserConfig = null;
  let mergedUserMeta = null;
  const badShards = [];
  const shardCounts = {};
  const shardDurMap = {};
  for (const file of sortedFiles) {
    const fullPath = path.join(folderPath, file);
    try {
      const shardRaw = fs.readFileSync(fullPath, "utf-8");
      const shardData = JSON.parse(shardRaw);
      if (!Array.isArray(shardData.results)) {
        console.warn(
          `Ortoni Report: Shard ${file} missing results array \u2014 skipping.`
        );
        badShards.push(file);
        continue;
      }
      shardData.results.forEach((r) => allResults.push(r));
      shardCounts[file] = shardData.results.length;
      if (Array.isArray(shardData.projectSet)) {
        shardData.projectSet.forEach((p) => projectSet.add(p));
      }
      const rawShardDur = shardData.totalDuration;
      let durToAdd = 0;
      let perTestSum = 0;
      if (typeof rawShardDur === "number") {
        durToAdd = rawShardDur;
      } else {
        perTestSum = Array.isArray(shardData.results) ? shardData.results.reduce(
          (acc, t) => acc + (Number(t?.duration) || 0),
          0
        ) : 0;
        durToAdd = perTestSum;
      }
      totalDurationSum += durToAdd;
      shardDurMap[file] = durToAdd;
      if (shardData.userConfig) {
        if (!mergedUserConfig) mergedUserConfig = { ...shardData.userConfig };
        else {
          Object.keys(shardData.userConfig).forEach((k) => {
            if (mergedUserConfig[k] === void 0 || mergedUserConfig[k] === null || mergedUserConfig[k] === "") {
              mergedUserConfig[k] = shardData.userConfig[k];
            } else if (shardData.userConfig[k] !== mergedUserConfig[k]) {
              console.warn(
                `Ortoni Report: userConfig mismatch for key "${k}" between shards. Using first value "${mergedUserConfig[k]}".`
              );
            }
          });
        }
      }
      if (shardData.userMeta) {
        if (!mergedUserMeta) mergedUserMeta = { ...shardData.userMeta };
        else {
          mergedUserMeta.meta = {
            ...mergedUserMeta.meta || {},
            ...shardData.userMeta.meta || {}
          };
        }
      }
    } catch (err) {
      console.error(`Ortoni Report: Failed to parse shard ${file}:`, err);
      badShards.push(file);
      continue;
    }
  }
  if (badShards.length > 0) {
    console.warn(
      `Ortoni Report: Completed merge with ${badShards.length} bad shard(s) skipped:`,
      badShards
    );
  }
  const totalDuration = totalDurationSum;
  const saveHistoryFromOptions = typeof options.saveHistory === "boolean" ? options.saveHistory : void 0;
  const saveHistoryFromShard = mergedUserConfig && typeof mergedUserConfig.saveHistory === "boolean" ? mergedUserConfig.saveHistory : void 0;
  const saveHistory = saveHistoryFromOptions ?? saveHistoryFromShard ?? true;
  let dbManager;
  let runId;
  if (saveHistory) {
    try {
      dbManager = new DatabaseManager();
      const dbPath = path.join(folderPath, "ortoni-data-history.sqlite");
      await dbManager.initialize(dbPath);
      runId = await dbManager.saveTestRun();
      if (typeof runId === "number") {
        await dbManager.saveTestResults(runId, allResults);
        console.info(
          `Ortoni Report: Saved ${allResults.length} results to DB (runId=${runId}).`
        );
      } else {
        console.warn(
          "Ortoni Report: Failed to create test run in DB; proceeding without saving results."
        );
      }
    } catch (err) {
      console.error(
        "Ortoni Report: Error while saving history to DB. Proceeding without DB:",
        err
      );
      dbManager = void 0;
      runId = void 0;
    }
  } else {
    console.info(
      "Ortoni Report: Skipping history save (saveHistory=false). (Typical for CI runs)"
    );
  }
  const htmlGenerator = new HTMLGenerator(
    { ...mergedUserConfig || {}, meta: mergedUserMeta?.meta },
    dbManager
  );
  const finalReportData = await htmlGenerator.generateFinalReport(
    // filteredResults: typically filter out skipped for display (keeps existing behavior)
    allResults.filter((r) => r.status !== "skipped"),
    totalDuration,
    allResults,
    projectSet
    // pass Set<string> as original generateFinalReport expects
  );
  const fileManager = new FileManager(folderPath);
  const outputFileName = options.file || "ortoni-report.html";
  const outputPath = fileManager.writeReportFile(
    outputFileName,
    finalReportData
  );
  console.log(`\u2705 Final merged report generated at ${await outputPath}`);
  console.log(`\u2705 Shards merged: ${sortedFiles.length}`);
  console.log(`\u2705 Tests per shard:`, shardCounts);
  console.log(`\u2705 Total tests merged ${allResults.length}`);
}

// src/cli.ts
program.version("4.0.1").description("Ortoni Report - CLI");
program.command("show-report").description("Open Ortoni Report").option(
  "-d, --dir <path>",
  "Path to the folder containing the report",
  "ortoni-report"
).option(
  "-f, --file <filename>",
  "Name of the report file",
  "ortoni-report.html"
).option("-p, --port <port>", "Port to run the server", "2004").action((options) => {
  const projectRoot = process.cwd();
  const folderPath = path2.resolve(projectRoot, options.dir);
  const filePath = path2.resolve(folderPath, options.file);
  const port = parseInt(options.port) || 2004;
  if (!fs2.existsSync(filePath)) {
    console.error(
      `\u274C Error: The file "${filePath}" does not exist in "${folderPath}".`
    );
    process.exit(1);
  }
  startReportServer(folderPath, path2.basename(filePath), port, "always");
});
program.command("merge-report").description("Merge sharded reports into one final report").option(
  "-d, --dir <path>",
  "Path to the folder containing shard files",
  "ortoni-report"
).option("-f, --file <filename>", "Output report file", "ortoni-report.html").action(async (options) => {
  await mergeAllData({
    dir: options.dir,
    file: options.file,
    saveHistory: false
  });
});
program.parse(process.argv);
