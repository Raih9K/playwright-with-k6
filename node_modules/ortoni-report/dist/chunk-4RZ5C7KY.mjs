var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// src/utils/utils.ts
import path from "path";
function normalizeFilePath(filePath) {
  const normalizedPath = path.normalize(filePath);
  return path.basename(normalizedPath);
}
function ensureHtmlExtension(filename) {
  const ext = path.extname(filename);
  if (ext && ext.toLowerCase() === ".html") {
    return filename;
  }
  return `${filename}.html`;
}
function escapeHtml(unsafe) {
  if (typeof unsafe !== "string") {
    return String(unsafe);
  }
  return unsafe.replace(/[&<"']/g, function(match) {
    const escapeMap = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#039;"
    };
    return escapeMap[match] || match;
  });
}
function formatDateLocal(dateInput) {
  const date = typeof dateInput === "string" ? new Date(dateInput) : dateInput;
  const options = {
    year: "numeric",
    month: "short",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
    hour12: true,
    timeZoneName: "short"
    // or "Asia/Kolkata"
  };
  return new Intl.DateTimeFormat(void 0, options).format(date);
}
function extractSuites(titlePath) {
  const tagPattern = /@[\w]+/g;
  const suiteParts = titlePath.slice(3, titlePath.length - 1).map((p) => p.replace(tagPattern, "").trim());
  return {
    hierarchy: suiteParts.join(" > "),
    // full hierarchy
    topLevelSuite: suiteParts[0] ?? "",
    // first suite
    parentSuite: suiteParts[suiteParts.length - 1] ?? ""
    // last suite
  };
}

// src/helpers/databaseManager.ts
import { open } from "sqlite";
import sqlite3 from "sqlite3";
var DatabaseManager = class {
  constructor() {
    this.db = null;
  }
  async initialize(dbPath) {
    try {
      this.db = await open({
        filename: dbPath,
        driver: sqlite3.Database
      });
      await this.createTables();
      await this.createIndexes();
    } catch (error) {
      console.error("OrtoniReport: Error initializing database:", error);
    }
  }
  async createTables() {
    if (!this.db) {
      console.error("OrtoniReport: Database not initialized");
      return;
    }
    try {
      await this.db.exec(`
        CREATE TABLE IF NOT EXISTS test_runs (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          run_date TEXT
        );

        CREATE TABLE IF NOT EXISTS test_results (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          run_id INTEGER,
          test_id TEXT,
          status TEXT,
          duration INTEGER, -- store duration as raw ms
          error_message TEXT,
          FOREIGN KEY (run_id) REFERENCES test_runs (id)
        );
      `);
    } catch (error) {
      console.error("OrtoniReport: Error creating tables:", error);
    }
  }
  async createIndexes() {
    if (!this.db) {
      console.error("OrtoniReport: Database not initialized");
      return;
    }
    try {
      await this.db.exec(`
        CREATE INDEX IF NOT EXISTS idx_test_id ON test_results (test_id);
        CREATE INDEX IF NOT EXISTS idx_run_id ON test_results (run_id);
      `);
    } catch (error) {
      console.error("OrtoniReport: Error creating indexes:", error);
    }
  }
  async saveTestRun() {
    if (!this.db) {
      console.error("OrtoniReport: Database not initialized");
      return null;
    }
    try {
      const runDate = (/* @__PURE__ */ new Date()).toISOString();
      const { lastID } = await this.db.run(
        `
        INSERT INTO test_runs (run_date)
        VALUES (?)
      `,
        [runDate]
      );
      return lastID;
    } catch (error) {
      console.error("OrtoniReport: Error saving test run:", error);
      return null;
    }
  }
  async saveTestResults(runId, results) {
    if (!this.db) {
      console.error("OrtoniReport: Database not initialized");
      return;
    }
    try {
      await this.db.exec("BEGIN TRANSACTION;");
      const stmt = await this.db.prepare(`
        INSERT INTO test_results (run_id, test_id, status, duration, error_message)
        VALUES (?, ?, ?, ?, ?)
      `);
      for (const result of results) {
        await stmt.run([
          runId,
          `${result.filePath}:${result.projectName}:${result.title}`,
          result.status,
          result.duration,
          // store raw ms
          result.errors.join("\n")
        ]);
      }
      await stmt.finalize();
      await this.db.exec("COMMIT;");
    } catch (error) {
      await this.db.exec("ROLLBACK;");
      console.error("OrtoniReport: Error saving test results:", error);
    }
  }
  async getTestHistory(testId, limit = 10) {
    if (!this.db) {
      console.error("OrtoniReport: Database not initialized");
      return [];
    }
    try {
      const results = await this.db.all(
        `
        SELECT tr.status, tr.duration, tr.error_message, trun.run_date
        FROM test_results tr
        JOIN test_runs trun ON tr.run_id = trun.id
        WHERE tr.test_id = ?
        ORDER BY trun.run_date DESC
        LIMIT ?
      `,
        [testId, limit]
      );
      return results.map((result) => ({
        ...result,
        run_date: formatDateLocal(result.run_date)
      }));
    } catch (error) {
      console.error("OrtoniReport: Error getting test history:", error);
      return [];
    }
  }
  async close() {
    if (this.db) {
      try {
        await this.db.close();
      } catch (error) {
        console.error("OrtoniReport: Error closing database:", error);
      } finally {
        this.db = null;
      }
    }
  }
  async getSummaryData() {
    if (!this.db) {
      console.error("OrtoniReport: Database not initialized");
      return {
        totalRuns: 0,
        totalTests: 0,
        passed: 0,
        failed: 0,
        passRate: 0,
        avgDuration: 0
      };
    }
    try {
      const summary = await this.db.get(`
      SELECT
        (SELECT COUNT(*) FROM test_runs) as totalRuns,
        (SELECT COUNT(*) FROM test_results) as totalTests,
        (SELECT COUNT(*) FROM test_results WHERE status = 'passed') as passed,
        (SELECT COUNT(*) FROM test_results WHERE status = 'failed') as failed,
        (SELECT AVG(duration) FROM test_results) as avgDuration
    `);
      const passRate = summary.totalTests ? (summary.passed / summary.totalTests * 100).toFixed(2) : 0;
      return {
        totalRuns: summary.totalRuns,
        totalTests: summary.totalTests,
        passed: summary.passed,
        failed: summary.failed,
        passRate: parseFloat(passRate.toString()),
        avgDuration: Math.round(summary.avgDuration || 0)
        // raw ms avg
      };
    } catch (error) {
      console.error("OrtoniReport: Error getting summary data:", error);
      return {
        totalRuns: 0,
        totalTests: 0,
        passed: 0,
        failed: 0,
        passRate: 0,
        avgDuration: 0
      };
    }
  }
  async getTrends(limit = 100) {
    if (!this.db) {
      console.error("OrtoniReport: Database not initialized");
      return [];
    }
    try {
      const rows = await this.db.all(
        `
      SELECT trun.run_date,
        SUM(CASE WHEN tr.status = 'passed' THEN 1 ELSE 0 END) AS passed,
        SUM(CASE WHEN tr.status = 'failed' THEN 1 ELSE 0 END) AS failed,
        AVG(tr.duration) AS avg_duration
      FROM test_results tr
      JOIN test_runs trun ON tr.run_id = trun.id
      GROUP BY trun.run_date
      ORDER BY trun.run_date DESC
      LIMIT ?
    `,
        [limit]
      );
      return rows.reverse().map((row) => ({
        ...row,
        run_date: formatDateLocal(row.run_date),
        avg_duration: Math.round(row.avg_duration || 0)
        // raw ms avg
      }));
    } catch (error) {
      console.error("OrtoniReport: Error getting trends data:", error);
      return [];
    }
  }
  async getFlakyTests(limit = 10) {
    if (!this.db) {
      console.error("OrtoniReport: Database not initialized");
      return [];
    }
    try {
      return await this.db.all(
        `
      SELECT
        test_id,
        COUNT(*) AS total,
        SUM(CASE WHEN status = 'flaky' THEN 1 ELSE 0 END) AS flaky,
        AVG(duration) AS avg_duration
      FROM test_results
      GROUP BY test_id
      HAVING flaky > 0
      ORDER BY flaky DESC
      LIMIT ?
    `,
        [limit]
      );
    } catch (error) {
      console.error("OrtoniReport: Error getting flaky tests:", error);
      return [];
    }
  }
  async getSlowTests(limit = 10) {
    if (!this.db) {
      console.error("OrtoniReport: Database not initialized");
      return [];
    }
    try {
      const rows = await this.db.all(
        `
      SELECT
        test_id,
        AVG(duration) AS avg_duration
      FROM test_results
      GROUP BY test_id
      ORDER BY avg_duration DESC
      LIMIT ?
    `,
        [limit]
      );
      return rows.map((row) => ({
        test_id: row.test_id,
        avg_duration: Math.round(row.avg_duration || 0)
        // raw ms avg
      }));
    } catch (error) {
      console.error("OrtoniReport: Error getting slow tests:", error);
      return [];
    }
  }
};

// src/utils/groupProjects.ts
function groupResults(config, results) {
  if (config.showProject) {
    const groupedResults = results.reduce((acc, result, index) => {
      const testId = `${result.filePath}:${result.projectName}:${result.title}`;
      const key = `${testId}-${result.key}-${result.retryAttemptCount}`;
      const { filePath, suite, projectName } = result;
      acc[filePath] = acc[filePath] || {};
      acc[filePath][suite] = acc[filePath][suite] || {};
      acc[filePath][suite][projectName] = acc[filePath][suite][projectName] || [];
      acc[filePath][suite][projectName].push({ ...result, index, testId, key });
      return acc;
    }, {});
    return groupedResults;
  } else {
    const groupedResults = results.reduce((acc, result, index) => {
      const testId = `${result.filePath}:${result.projectName}:${result.title}`;
      const key = `${testId}-${result.key}-${result.retryAttemptCount}`;
      const { filePath, suite } = result;
      acc[filePath] = acc[filePath] || {};
      acc[filePath][suite] = acc[filePath][suite] || [];
      acc[filePath][suite].push({ ...result, index, testId, key });
      return acc;
    }, {});
    return groupedResults;
  }
}

// src/helpers/HTMLGenerator.ts
var HTMLGenerator = class {
  constructor(ortoniConfig, dbManager) {
    this.ortoniConfig = ortoniConfig;
    this.dbManager = dbManager;
  }
  async generateFinalReport(filteredResults, totalDuration, results, projectSet) {
    const data = await this.prepareReportData(
      filteredResults,
      totalDuration,
      results,
      projectSet
    );
    return data;
  }
  /**
   * Return safe analytics/report data.
   * If no dbManager is provided, return empty defaults and a note explaining why.
   */
  async getReportData() {
    if (!this.dbManager) {
      return {
        summary: {},
        trends: {},
        flakyTests: [],
        slowTests: [],
        note: "Test history/trends are unavailable (saveHistory disabled or DB not initialized)."
      };
    }
    try {
      const [summary, trends, flakyTests, slowTests] = await Promise.all([
        this.dbManager.getSummaryData ? this.dbManager.getSummaryData() : Promise.resolve({}),
        this.dbManager.getTrends ? this.dbManager.getTrends() : Promise.resolve({}),
        this.dbManager.getFlakyTests ? this.dbManager.getFlakyTests() : Promise.resolve([]),
        this.dbManager.getSlowTests ? this.dbManager.getSlowTests() : Promise.resolve([])
      ]);
      return {
        summary: summary ?? {},
        trends: trends ?? {},
        flakyTests: flakyTests ?? [],
        slowTests: slowTests ?? []
      };
    } catch (err) {
      console.warn(
        "HTMLGenerator: failed to read analytics from DB, continuing without history.",
        err
      );
      return {
        summary: {},
        trends: {},
        flakyTests: [],
        slowTests: [],
        note: "Test history/trends could not be loaded due to a DB error."
      };
    }
  }
  async prepareReportData(filteredResults, totalDuration, results, projectSet) {
    const totalTests = filteredResults.length;
    const passedTests = results.filter((r) => r.status === "passed").length;
    const flakyTests = results.filter((r) => r.status === "flaky").length;
    const failed = filteredResults.filter(
      (r) => r.status === "failed" || r.status === "timedOut"
    ).length;
    const successRate = totalTests === 0 ? "0.00" : ((passedTests + flakyTests) / totalTests * 100).toFixed(2);
    const allTags = /* @__PURE__ */ new Set();
    results.forEach(
      (result) => (result.testTags || []).forEach((tag) => allTags.add(tag))
    );
    const projectResults = this.calculateProjectResults(
      filteredResults,
      results,
      projectSet
    );
    const lastRunDate = (/* @__PURE__ */ new Date()).toLocaleString();
    const testHistories = await Promise.all(
      results.map(async (result) => {
        const testId = `${result.filePath}:${result.projectName}:${result.title}`;
        if (!this.dbManager || !this.dbManager.getTestHistory) {
          return {
            testId,
            history: []
          };
        }
        try {
          const history = await this.dbManager.getTestHistory(testId);
          return {
            testId,
            history: history ?? []
          };
        } catch (err) {
          console.warn(
            `HTMLGenerator: failed to read history for ${testId}`,
            err
          );
          return {
            testId,
            history: []
          };
        }
      })
    );
    const reportData = await this.getReportData();
    return {
      summary: {
        overAllResult: {
          pass: passedTests,
          fail: failed,
          skip: results.filter((r) => r.status === "skipped").length,
          retry: results.filter((r) => r.retryAttemptCount).length,
          flaky: flakyTests,
          total: filteredResults.length
        },
        successRate,
        lastRunDate,
        totalDuration,
        stats: this.extractProjectStats(projectResults)
      },
      testResult: {
        tests: groupResults(this.ortoniConfig, results),
        testHistories,
        allTags: Array.from(allTags),
        set: projectSet
      },
      userConfig: {
        projectName: this.ortoniConfig.projectName,
        authorName: this.ortoniConfig.authorName,
        type: this.ortoniConfig.testType,
        title: this.ortoniConfig.title
      },
      userMeta: {
        meta: this.ortoniConfig.meta
      },
      preferences: {
        logo: this.ortoniConfig.logo || void 0,
        showProject: this.ortoniConfig.showProject || false
      },
      analytics: {
        reportData
      }
    };
  }
  calculateProjectResults(filteredResults, results, projectSet) {
    return Array.from(projectSet).map((projectName) => {
      const projectTests = filteredResults.filter(
        (r) => r.projectName === projectName
      );
      const allProjectTests = results.filter(
        (r) => r.projectName === projectName
      );
      return {
        projectName,
        passedTests: projectTests.filter((r) => r.status === "passed").length,
        failedTests: projectTests.filter(
          (r) => r.status === "failed" || r.status === "timedOut"
        ).length,
        skippedTests: allProjectTests.filter((r) => r.status === "skipped").length,
        retryTests: allProjectTests.filter((r) => r.retryAttemptCount).length,
        flakyTests: allProjectTests.filter((r) => r.status === "flaky").length,
        totalTests: projectTests.length
      };
    });
  }
  extractProjectStats(projectResults) {
    return {
      projectNames: projectResults.map((result) => result.projectName),
      totalTests: projectResults.map((result) => result.totalTests),
      passedTests: projectResults.map((result) => result.passedTests),
      failedTests: projectResults.map((result) => result.failedTests),
      skippedTests: projectResults.map((result) => result.skippedTests),
      retryTests: projectResults.map((result) => result.retryTests),
      flakyTests: projectResults.map((result) => result.flakyTests)
    };
  }
};

// src/helpers/fileManager.ts
import fs2 from "fs";
import path3 from "path";

// src/helpers/templateLoader.ts
import fs from "fs";
import path2 from "path";
async function readBundledTemplate(pkgName = "ortoni-report") {
  const packagedRel = "dist/index.html";
  try {
    if (typeof __require === "function") {
      const resolved = __require.resolve(`${pkgName}/${packagedRel}`);
      if (fs.existsSync(resolved)) {
        return fs.readFileSync(resolved, "utf-8");
      }
    }
  } catch {
  }
  try {
    const moduleNS = await import("module");
    if (moduleNS && typeof moduleNS.createRequire === "function") {
      const createRequire = moduleNS.createRequire;
      const req = createRequire(
        // @ts-ignore
        typeof __filename !== "undefined" ? __filename : import.meta.url
      );
      const resolved = req.resolve(`${pkgName}/${packagedRel}`);
      if (fs.existsSync(resolved)) {
        return fs.readFileSync(resolved, "utf-8");
      }
    }
  } catch {
  }
  try {
    const here = path2.resolve(__dirname, "../dist/index.html");
    if (fs.existsSync(here)) return fs.readFileSync(here, "utf-8");
  } catch {
  }
  try {
    const nm = path2.join(process.cwd(), "node_modules", pkgName, packagedRel);
    if (fs.existsSync(nm)) return fs.readFileSync(nm, "utf-8");
  } catch {
  }
  try {
    const alt = path2.join(process.cwd(), "dist", "index.html");
    if (fs.existsSync(alt)) return fs.readFileSync(alt, "utf-8");
  } catch {
  }
  throw new Error(
    `ortoni-report template not found (tried:
  - require.resolve('${pkgName}/${packagedRel}')
  - import('module').createRequire(...).resolve('${pkgName}/${packagedRel}')
  - relative ../dist/index.html
  - ${path2.join(
      process.cwd(),
      "node_modules",
      pkgName,
      packagedRel
    )}
  - ${path2.join(process.cwd(), "dist", "index.html")}
Ensure 'dist/index.html' is present in the published package and package.json 'files' includes 'dist/'.`
  );
}

// src/helpers/fileManager.ts
var FileManager = class {
  constructor(folderPath) {
    this.folderPath = folderPath;
  }
  ensureReportDirectory() {
    const ortoniDataFolder = path3.join(this.folderPath, "ortoni-data");
    if (!fs2.existsSync(this.folderPath)) {
      fs2.mkdirSync(this.folderPath, { recursive: true });
    } else {
      if (fs2.existsSync(ortoniDataFolder)) {
        fs2.rmSync(ortoniDataFolder, { recursive: true, force: true });
      }
    }
  }
  async writeReportFile(filename, data) {
    let html = await readBundledTemplate();
    const reportJSON = JSON.stringify({
      data
    });
    html = html.replace("__ORTONI_TEST_REPORTDATA__", reportJSON);
    const outputPath = path3.join(process.cwd(), this.folderPath, filename);
    fs2.writeFileSync(outputPath, html);
    return outputPath;
  }
  writeRawFile(filename, data) {
    const outputPath = path3.join(process.cwd(), this.folderPath, filename);
    fs2.mkdirSync(path3.dirname(outputPath), { recursive: true });
    const content = typeof data === "string" ? data : JSON.stringify(data, null, 2);
    fs2.writeFileSync(outputPath, content, "utf-8");
    return outputPath;
  }
  copyTraceViewerAssets(skip) {
    if (skip) return;
    const traceViewerFolder = path3.join(
      __require.resolve("playwright-core"),
      "..",
      "lib",
      "vite",
      "traceViewer"
    );
    const traceViewerTargetFolder = path3.join(this.folderPath, "trace");
    const traceViewerAssetsTargetFolder = path3.join(
      traceViewerTargetFolder,
      "assets"
    );
    fs2.mkdirSync(traceViewerAssetsTargetFolder, { recursive: true });
    for (const file of fs2.readdirSync(traceViewerFolder)) {
      if (file.endsWith(".map") || file.includes("watch") || file.includes("assets"))
        continue;
      fs2.copyFileSync(
        path3.join(traceViewerFolder, file),
        path3.join(traceViewerTargetFolder, file)
      );
    }
    const assetsFolder = path3.join(traceViewerFolder, "assets");
    for (const file of fs2.readdirSync(assetsFolder)) {
      if (file.endsWith(".map") || file.includes("xtermModule")) continue;
      fs2.copyFileSync(
        path3.join(assetsFolder, file),
        path3.join(traceViewerAssetsTargetFolder, file)
      );
    }
  }
};

// src/utils/expressServer.ts
import express from "express";
import path4 from "path";
import { spawn } from "child_process";
function startReportServer(reportFolder, reportFilename, port = 2004, open2) {
  const app = express();
  app.use(express.static(reportFolder, { index: false }));
  app.get("/", (_req, res) => {
    try {
      res.sendFile(path4.resolve(reportFolder, reportFilename));
    } catch (error) {
      console.error("Ortoni Report: Error sending report file:", error);
      res.status(500).send("Error loading report");
    }
  });
  try {
    const server = app.listen(port, () => {
      console.log(
        `Server is running at http://localhost:${port} 
Press Ctrl+C to stop.`
      );
      if (open2 === "always" || open2 === "on-failure") {
        try {
          openBrowser(`http://localhost:${port}`);
        } catch (error) {
          console.error("Ortoni Report: Error opening browser:", error);
        }
      }
    });
    server.on("error", (error) => {
      if (error.code === "EADDRINUSE") {
        console.error(
          `Ortoni Report: Port ${port} is already in use. Trying a different port...`
        );
      } else {
        console.error("Ortoni Report: Server error:", error);
      }
    });
  } catch (error) {
    console.error("Ortoni Report: Error starting the server:", error);
  }
}
function openBrowser(url) {
  const platform = process.platform;
  let command;
  try {
    if (platform === "win32") {
      command = "cmd";
      spawn(command, ["/c", "start", url]);
    } else if (platform === "darwin") {
      command = "open";
      spawn(command, [url]);
    } else {
      command = "xdg-open";
      spawn(command, [url]);
    }
  } catch (error) {
    console.error("Ortoni Report: Error opening the browser:", error);
  }
}

export {
  __publicField,
  normalizeFilePath,
  ensureHtmlExtension,
  escapeHtml,
  extractSuites,
  DatabaseManager,
  HTMLGenerator,
  FileManager,
  startReportServer
};
