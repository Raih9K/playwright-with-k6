#!/usr/bin/env node
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// src/cli.ts
var import_commander = require("commander");
var fs4 = __toESM(require("fs"));
var path5 = __toESM(require("path"));

// src/mergeData.ts
var fs3 = __toESM(require("fs"));
var path3 = __toESM(require("path"));

// src/helpers/databaseManager.ts
var import_sqlite = require("sqlite");
var import_sqlite3 = __toESM(require("sqlite3"));

// src/utils/utils.ts
function formatDateLocal(dateInput) {
  const date = typeof dateInput === "string" ? new Date(dateInput) : dateInput;
  const options = {
    year: "numeric",
    month: "short",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
    hour12: true,
    timeZoneName: "short"
    // or "Asia/Kolkata"
  };
  return new Intl.DateTimeFormat(void 0, options).format(date);
}

// src/helpers/databaseManager.ts
var DatabaseManager = class {
  constructor() {
    this.db = null;
  }
  async initialize(dbPath) {
    try {
      this.db = await (0, import_sqlite.open)({
        filename: dbPath,
        driver: import_sqlite3.default.Database
      });
      await this.createTables();
      await this.createIndexes();
    } catch (error) {
      console.error("OrtoniReport: Error initializing database:", error);
    }
  }
  async createTables() {
    if (!this.db) {
      console.error("OrtoniReport: Database not initialized");
      return;
    }
    try {
      await this.db.exec(`
        CREATE TABLE IF NOT EXISTS test_runs (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          run_date TEXT
        );

        CREATE TABLE IF NOT EXISTS test_results (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          run_id INTEGER,
          test_id TEXT,
          status TEXT,
          duration INTEGER, -- store duration as raw ms
          error_message TEXT,
          FOREIGN KEY (run_id) REFERENCES test_runs (id)
        );
      `);
    } catch (error) {
      console.error("OrtoniReport: Error creating tables:", error);
    }
  }
  async createIndexes() {
    if (!this.db) {
      console.error("OrtoniReport: Database not initialized");
      return;
    }
    try {
      await this.db.exec(`
        CREATE INDEX IF NOT EXISTS idx_test_id ON test_results (test_id);
        CREATE INDEX IF NOT EXISTS idx_run_id ON test_results (run_id);
      `);
    } catch (error) {
      console.error("OrtoniReport: Error creating indexes:", error);
    }
  }
  async saveTestRun() {
    if (!this.db) {
      console.error("OrtoniReport: Database not initialized");
      return null;
    }
    try {
      const runDate = (/* @__PURE__ */ new Date()).toISOString();
      const { lastID } = await this.db.run(
        `
        INSERT INTO test_runs (run_date)
        VALUES (?)
      `,
        [runDate]
      );
      return lastID;
    } catch (error) {
      console.error("OrtoniReport: Error saving test run:", error);
      return null;
    }
  }
  async saveTestResults(runId, results) {
    if (!this.db) {
      console.error("OrtoniReport: Database not initialized");
      return;
    }
    try {
      await this.db.exec("BEGIN TRANSACTION;");
      const stmt = await this.db.prepare(`
        INSERT INTO test_results (run_id, test_id, status, duration, error_message)
        VALUES (?, ?, ?, ?, ?)
      `);
      for (const result of results) {
        await stmt.run([
          runId,
          `${result.filePath}:${result.projectName}:${result.title}`,
          result.status,
          result.duration,
          // store raw ms
          result.errors.join("\n")
        ]);
      }
      await stmt.finalize();
      await this.db.exec("COMMIT;");
    } catch (error) {
      await this.db.exec("ROLLBACK;");
      console.error("OrtoniReport: Error saving test results:", error);
    }
  }
  async getTestHistory(testId, limit = 10) {
    if (!this.db) {
      console.error("OrtoniReport: Database not initialized");
      return [];
    }
    try {
      const results = await this.db.all(
        `
        SELECT tr.status, tr.duration, tr.error_message, trun.run_date
        FROM test_results tr
        JOIN test_runs trun ON tr.run_id = trun.id
        WHERE tr.test_id = ?
        ORDER BY trun.run_date DESC
        LIMIT ?
      `,
        [testId, limit]
      );
      return results.map((result) => ({
        ...result,
        run_date: formatDateLocal(result.run_date)
      }));
    } catch (error) {
      console.error("OrtoniReport: Error getting test history:", error);
      return [];
    }
  }
  async close() {
    if (this.db) {
      try {
        await this.db.close();
      } catch (error) {
        console.error("OrtoniReport: Error closing database:", error);
      } finally {
        this.db = null;
      }
    }
  }
  async getSummaryData() {
    if (!this.db) {
      console.error("OrtoniReport: Database not initialized");
      return {
        totalRuns: 0,
        totalTests: 0,
        passed: 0,
        failed: 0,
        passRate: 0,
        avgDuration: 0
      };
    }
    try {
      const summary = await this.db.get(`
      SELECT
        (SELECT COUNT(*) FROM test_runs) as totalRuns,
        (SELECT COUNT(*) FROM test_results) as totalTests,
        (SELECT COUNT(*) FROM test_results WHERE status = 'passed') as passed,
        (SELECT COUNT(*) FROM test_results WHERE status = 'failed') as failed,
        (SELECT AVG(duration) FROM test_results) as avgDuration
    `);
      const passRate = summary.totalTests ? (summary.passed / summary.totalTests * 100).toFixed(2) : 0;
      return {
        totalRuns: summary.totalRuns,
        totalTests: summary.totalTests,
        passed: summary.passed,
        failed: summary.failed,
        passRate: parseFloat(passRate.toString()),
        avgDuration: Math.round(summary.avgDuration || 0)
        // raw ms avg
      };
    } catch (error) {
      console.error("OrtoniReport: Error getting summary data:", error);
      return {
        totalRuns: 0,
        totalTests: 0,
        passed: 0,
        failed: 0,
        passRate: 0,
        avgDuration: 0
      };
    }
  }
  async getTrends(limit = 100) {
    if (!this.db) {
      console.error("OrtoniReport: Database not initialized");
      return [];
    }
    try {
      const rows = await this.db.all(
        `
      SELECT trun.run_date,
        SUM(CASE WHEN tr.status = 'passed' THEN 1 ELSE 0 END) AS passed,
        SUM(CASE WHEN tr.status = 'failed' THEN 1 ELSE 0 END) AS failed,
        AVG(tr.duration) AS avg_duration
      FROM test_results tr
      JOIN test_runs trun ON tr.run_id = trun.id
      GROUP BY trun.run_date
      ORDER BY trun.run_date DESC
      LIMIT ?
    `,
        [limit]
      );
      return rows.reverse().map((row) => ({
        ...row,
        run_date: formatDateLocal(row.run_date),
        avg_duration: Math.round(row.avg_duration || 0)
        // raw ms avg
      }));
    } catch (error) {
      console.error("OrtoniReport: Error getting trends data:", error);
      return [];
    }
  }
  async getFlakyTests(limit = 10) {
    if (!this.db) {
      console.error("OrtoniReport: Database not initialized");
      return [];
    }
    try {
      return await this.db.all(
        `
      SELECT
        test_id,
        COUNT(*) AS total,
        SUM(CASE WHEN status = 'flaky' THEN 1 ELSE 0 END) AS flaky,
        AVG(duration) AS avg_duration
      FROM test_results
      GROUP BY test_id
      HAVING flaky > 0
      ORDER BY flaky DESC
      LIMIT ?
    `,
        [limit]
      );
    } catch (error) {
      console.error("OrtoniReport: Error getting flaky tests:", error);
      return [];
    }
  }
  async getSlowTests(limit = 10) {
    if (!this.db) {
      console.error("OrtoniReport: Database not initialized");
      return [];
    }
    try {
      const rows = await this.db.all(
        `
      SELECT
        test_id,
        AVG(duration) AS avg_duration
      FROM test_results
      GROUP BY test_id
      ORDER BY avg_duration DESC
      LIMIT ?
    `,
        [limit]
      );
      return rows.map((row) => ({
        test_id: row.test_id,
        avg_duration: Math.round(row.avg_duration || 0)
        // raw ms avg
      }));
    } catch (error) {
      console.error("OrtoniReport: Error getting slow tests:", error);
      return [];
    }
  }
};

// src/utils/groupProjects.ts
function groupResults(config, results) {
  if (config.showProject) {
    const groupedResults = results.reduce((acc, result, index) => {
      const testId = `${result.filePath}:${result.projectName}:${result.title}`;
      const key = `${testId}-${result.key}-${result.retryAttemptCount}`;
      const { filePath, suite, projectName } = result;
      acc[filePath] = acc[filePath] || {};
      acc[filePath][suite] = acc[filePath][suite] || {};
      acc[filePath][suite][projectName] = acc[filePath][suite][projectName] || [];
      acc[filePath][suite][projectName].push({ ...result, index, testId, key });
      return acc;
    }, {});
    return groupedResults;
  } else {
    const groupedResults = results.reduce((acc, result, index) => {
      const testId = `${result.filePath}:${result.projectName}:${result.title}`;
      const key = `${testId}-${result.key}-${result.retryAttemptCount}`;
      const { filePath, suite } = result;
      acc[filePath] = acc[filePath] || {};
      acc[filePath][suite] = acc[filePath][suite] || [];
      acc[filePath][suite].push({ ...result, index, testId, key });
      return acc;
    }, {});
    return groupedResults;
  }
}

// src/helpers/HTMLGenerator.ts
var HTMLGenerator = class {
  constructor(ortoniConfig, dbManager) {
    this.ortoniConfig = ortoniConfig;
    this.dbManager = dbManager;
  }
  async generateFinalReport(filteredResults, totalDuration, results, projectSet) {
    const data = await this.prepareReportData(
      filteredResults,
      totalDuration,
      results,
      projectSet
    );
    return data;
  }
  /**
   * Return safe analytics/report data.
   * If no dbManager is provided, return empty defaults and a note explaining why.
   */
  async getReportData() {
    if (!this.dbManager) {
      return {
        summary: {},
        trends: {},
        flakyTests: [],
        slowTests: [],
        note: "Test history/trends are unavailable (saveHistory disabled or DB not initialized)."
      };
    }
    try {
      const [summary, trends, flakyTests, slowTests] = await Promise.all([
        this.dbManager.getSummaryData ? this.dbManager.getSummaryData() : Promise.resolve({}),
        this.dbManager.getTrends ? this.dbManager.getTrends() : Promise.resolve({}),
        this.dbManager.getFlakyTests ? this.dbManager.getFlakyTests() : Promise.resolve([]),
        this.dbManager.getSlowTests ? this.dbManager.getSlowTests() : Promise.resolve([])
      ]);
      return {
        summary: summary ?? {},
        trends: trends ?? {},
        flakyTests: flakyTests ?? [],
        slowTests: slowTests ?? []
      };
    } catch (err) {
      console.warn(
        "HTMLGenerator: failed to read analytics from DB, continuing without history.",
        err
      );
      return {
        summary: {},
        trends: {},
        flakyTests: [],
        slowTests: [],
        note: "Test history/trends could not be loaded due to a DB error."
      };
    }
  }
  async prepareReportData(filteredResults, totalDuration, results, projectSet) {
    const totalTests = filteredResults.length;
    const passedTests = results.filter((r) => r.status === "passed").length;
    const flakyTests = results.filter((r) => r.status === "flaky").length;
    const failed = filteredResults.filter(
      (r) => r.status === "failed" || r.status === "timedOut"
    ).length;
    const successRate = totalTests === 0 ? "0.00" : ((passedTests + flakyTests) / totalTests * 100).toFixed(2);
    const allTags = /* @__PURE__ */ new Set();
    results.forEach(
      (result) => (result.testTags || []).forEach((tag) => allTags.add(tag))
    );
    const projectResults = this.calculateProjectResults(
      filteredResults,
      results,
      projectSet
    );
    const lastRunDate = (/* @__PURE__ */ new Date()).toLocaleString();
    const testHistories = await Promise.all(
      results.map(async (result) => {
        const testId = `${result.filePath}:${result.projectName}:${result.title}`;
        if (!this.dbManager || !this.dbManager.getTestHistory) {
          return {
            testId,
            history: []
          };
        }
        try {
          const history = await this.dbManager.getTestHistory(testId);
          return {
            testId,
            history: history ?? []
          };
        } catch (err) {
          console.warn(
            `HTMLGenerator: failed to read history for ${testId}`,
            err
          );
          return {
            testId,
            history: []
          };
        }
      })
    );
    const reportData = await this.getReportData();
    return {
      summary: {
        overAllResult: {
          pass: passedTests,
          fail: failed,
          skip: results.filter((r) => r.status === "skipped").length,
          retry: results.filter((r) => r.retryAttemptCount).length,
          flaky: flakyTests,
          total: filteredResults.length
        },
        successRate,
        lastRunDate,
        totalDuration,
        stats: this.extractProjectStats(projectResults)
      },
      testResult: {
        tests: groupResults(this.ortoniConfig, results),
        testHistories,
        allTags: Array.from(allTags),
        set: projectSet
      },
      userConfig: {
        projectName: this.ortoniConfig.projectName,
        authorName: this.ortoniConfig.authorName,
        type: this.ortoniConfig.testType,
        title: this.ortoniConfig.title
      },
      userMeta: {
        meta: this.ortoniConfig.meta
      },
      preferences: {
        logo: this.ortoniConfig.logo || void 0,
        showProject: this.ortoniConfig.showProject || false
      },
      analytics: {
        reportData
      }
    };
  }
  calculateProjectResults(filteredResults, results, projectSet) {
    return Array.from(projectSet).map((projectName) => {
      const projectTests = filteredResults.filter(
        (r) => r.projectName === projectName
      );
      const allProjectTests = results.filter(
        (r) => r.projectName === projectName
      );
      return {
        projectName,
        passedTests: projectTests.filter((r) => r.status === "passed").length,
        failedTests: projectTests.filter(
          (r) => r.status === "failed" || r.status === "timedOut"
        ).length,
        skippedTests: allProjectTests.filter((r) => r.status === "skipped").length,
        retryTests: allProjectTests.filter((r) => r.retryAttemptCount).length,
        flakyTests: allProjectTests.filter((r) => r.status === "flaky").length,
        totalTests: projectTests.length
      };
    });
  }
  extractProjectStats(projectResults) {
    return {
      projectNames: projectResults.map((result) => result.projectName),
      totalTests: projectResults.map((result) => result.totalTests),
      passedTests: projectResults.map((result) => result.passedTests),
      failedTests: projectResults.map((result) => result.failedTests),
      skippedTests: projectResults.map((result) => result.skippedTests),
      retryTests: projectResults.map((result) => result.retryTests),
      flakyTests: projectResults.map((result) => result.flakyTests)
    };
  }
};

// src/helpers/fileManager.ts
var import_fs2 = __toESM(require("fs"));
var import_path2 = __toESM(require("path"));

// src/helpers/templateLoader.ts
var import_fs = __toESM(require("fs"));
var import_path = __toESM(require("path"));
var import_meta = {};
async function readBundledTemplate(pkgName = "ortoni-report") {
  const packagedRel = "dist/index.html";
  try {
    if (typeof require === "function") {
      const resolved = require.resolve(`${pkgName}/${packagedRel}`);
      if (import_fs.default.existsSync(resolved)) {
        return import_fs.default.readFileSync(resolved, "utf-8");
      }
    }
  } catch {
  }
  try {
    const moduleNS = await import("module");
    if (moduleNS && typeof moduleNS.createRequire === "function") {
      const createRequire = moduleNS.createRequire;
      const req = createRequire(
        // @ts-ignore
        typeof __filename !== "undefined" ? __filename : import_meta.url
      );
      const resolved = req.resolve(`${pkgName}/${packagedRel}`);
      if (import_fs.default.existsSync(resolved)) {
        return import_fs.default.readFileSync(resolved, "utf-8");
      }
    }
  } catch {
  }
  try {
    const here = import_path.default.resolve(__dirname, "../dist/index.html");
    if (import_fs.default.existsSync(here)) return import_fs.default.readFileSync(here, "utf-8");
  } catch {
  }
  try {
    const nm = import_path.default.join(process.cwd(), "node_modules", pkgName, packagedRel);
    if (import_fs.default.existsSync(nm)) return import_fs.default.readFileSync(nm, "utf-8");
  } catch {
  }
  try {
    const alt = import_path.default.join(process.cwd(), "dist", "index.html");
    if (import_fs.default.existsSync(alt)) return import_fs.default.readFileSync(alt, "utf-8");
  } catch {
  }
  throw new Error(
    `ortoni-report template not found (tried:
  - require.resolve('${pkgName}/${packagedRel}')
  - import('module').createRequire(...).resolve('${pkgName}/${packagedRel}')
  - relative ../dist/index.html
  - ${import_path.default.join(
      process.cwd(),
      "node_modules",
      pkgName,
      packagedRel
    )}
  - ${import_path.default.join(process.cwd(), "dist", "index.html")}
Ensure 'dist/index.html' is present in the published package and package.json 'files' includes 'dist/'.`
  );
}

// src/helpers/fileManager.ts
var FileManager = class {
  constructor(folderPath) {
    this.folderPath = folderPath;
  }
  ensureReportDirectory() {
    const ortoniDataFolder = import_path2.default.join(this.folderPath, "ortoni-data");
    if (!import_fs2.default.existsSync(this.folderPath)) {
      import_fs2.default.mkdirSync(this.folderPath, { recursive: true });
    } else {
      if (import_fs2.default.existsSync(ortoniDataFolder)) {
        import_fs2.default.rmSync(ortoniDataFolder, { recursive: true, force: true });
      }
    }
  }
  async writeReportFile(filename, data) {
    let html = await readBundledTemplate();
    const reportJSON = JSON.stringify({
      data
    });
    html = html.replace("__ORTONI_TEST_REPORTDATA__", reportJSON);
    const outputPath = import_path2.default.join(process.cwd(), this.folderPath, filename);
    import_fs2.default.writeFileSync(outputPath, html);
    return outputPath;
  }
  writeRawFile(filename, data) {
    const outputPath = import_path2.default.join(process.cwd(), this.folderPath, filename);
    import_fs2.default.mkdirSync(import_path2.default.dirname(outputPath), { recursive: true });
    const content = typeof data === "string" ? data : JSON.stringify(data, null, 2);
    import_fs2.default.writeFileSync(outputPath, content, "utf-8");
    return outputPath;
  }
  copyTraceViewerAssets(skip) {
    if (skip) return;
    const traceViewerFolder = import_path2.default.join(
      require.resolve("playwright-core"),
      "..",
      "lib",
      "vite",
      "traceViewer"
    );
    const traceViewerTargetFolder = import_path2.default.join(this.folderPath, "trace");
    const traceViewerAssetsTargetFolder = import_path2.default.join(
      traceViewerTargetFolder,
      "assets"
    );
    import_fs2.default.mkdirSync(traceViewerAssetsTargetFolder, { recursive: true });
    for (const file of import_fs2.default.readdirSync(traceViewerFolder)) {
      if (file.endsWith(".map") || file.includes("watch") || file.includes("assets"))
        continue;
      import_fs2.default.copyFileSync(
        import_path2.default.join(traceViewerFolder, file),
        import_path2.default.join(traceViewerTargetFolder, file)
      );
    }
    const assetsFolder = import_path2.default.join(traceViewerFolder, "assets");
    for (const file of import_fs2.default.readdirSync(assetsFolder)) {
      if (file.endsWith(".map") || file.includes("xtermModule")) continue;
      import_fs2.default.copyFileSync(
        import_path2.default.join(assetsFolder, file),
        import_path2.default.join(traceViewerAssetsTargetFolder, file)
      );
    }
  }
};

// src/mergeData.ts
async function mergeAllData(options = {}) {
  const folderPath = options.dir || "ortoni-report";
  console.info(`Ortoni Report: Merging shard files in folder: ${folderPath}`);
  if (!fs3.existsSync(folderPath)) {
    console.error(`Ortoni Report: folder "${folderPath}" does not exist.`);
    process.exitCode = 1;
    return;
  }
  const filenames = fs3.readdirSync(folderPath).filter((f) => f.startsWith("ortoni-shard-") && f.endsWith(".json"));
  if (filenames.length === 0) {
    console.error("Ortoni Report: \u274C No shard files found to merge.");
    process.exitCode = 1;
    return;
  }
  const shardFileIndex = (name) => {
    const m = name.match(/ortoni-shard-(\d+)-of-(\d+)\.json$/);
    return m ? parseInt(m[1], 10) : null;
  };
  const sortedFiles = filenames.map((f) => ({ f, idx: shardFileIndex(f) })).sort((a, b) => {
    if (a.idx === null && b.idx === null) return a.f.localeCompare(b.f);
    if (a.idx === null) return 1;
    if (b.idx === null) return -1;
    return a.idx - b.idx;
  }).map((x) => x.f);
  const allResults = [];
  const projectSet = /* @__PURE__ */ new Set();
  let totalDurationSum = 0;
  let mergedUserConfig = null;
  let mergedUserMeta = null;
  const badShards = [];
  const shardCounts = {};
  const shardDurMap = {};
  for (const file of sortedFiles) {
    const fullPath = path3.join(folderPath, file);
    try {
      const shardRaw = fs3.readFileSync(fullPath, "utf-8");
      const shardData = JSON.parse(shardRaw);
      if (!Array.isArray(shardData.results)) {
        console.warn(
          `Ortoni Report: Shard ${file} missing results array \u2014 skipping.`
        );
        badShards.push(file);
        continue;
      }
      shardData.results.forEach((r) => allResults.push(r));
      shardCounts[file] = shardData.results.length;
      if (Array.isArray(shardData.projectSet)) {
        shardData.projectSet.forEach((p) => projectSet.add(p));
      }
      const rawShardDur = shardData.totalDuration;
      let durToAdd = 0;
      let perTestSum = 0;
      if (typeof rawShardDur === "number") {
        durToAdd = rawShardDur;
      } else {
        perTestSum = Array.isArray(shardData.results) ? shardData.results.reduce(
          (acc, t) => acc + (Number(t?.duration) || 0),
          0
        ) : 0;
        durToAdd = perTestSum;
      }
      totalDurationSum += durToAdd;
      shardDurMap[file] = durToAdd;
      if (shardData.userConfig) {
        if (!mergedUserConfig) mergedUserConfig = { ...shardData.userConfig };
        else {
          Object.keys(shardData.userConfig).forEach((k) => {
            if (mergedUserConfig[k] === void 0 || mergedUserConfig[k] === null || mergedUserConfig[k] === "") {
              mergedUserConfig[k] = shardData.userConfig[k];
            } else if (shardData.userConfig[k] !== mergedUserConfig[k]) {
              console.warn(
                `Ortoni Report: userConfig mismatch for key "${k}" between shards. Using first value "${mergedUserConfig[k]}".`
              );
            }
          });
        }
      }
      if (shardData.userMeta) {
        if (!mergedUserMeta) mergedUserMeta = { ...shardData.userMeta };
        else {
          mergedUserMeta.meta = {
            ...mergedUserMeta.meta || {},
            ...shardData.userMeta.meta || {}
          };
        }
      }
    } catch (err) {
      console.error(`Ortoni Report: Failed to parse shard ${file}:`, err);
      badShards.push(file);
      continue;
    }
  }
  if (badShards.length > 0) {
    console.warn(
      `Ortoni Report: Completed merge with ${badShards.length} bad shard(s) skipped:`,
      badShards
    );
  }
  const totalDuration = totalDurationSum;
  const saveHistoryFromOptions = typeof options.saveHistory === "boolean" ? options.saveHistory : void 0;
  const saveHistoryFromShard = mergedUserConfig && typeof mergedUserConfig.saveHistory === "boolean" ? mergedUserConfig.saveHistory : void 0;
  const saveHistory = saveHistoryFromOptions ?? saveHistoryFromShard ?? true;
  let dbManager;
  let runId;
  if (saveHistory) {
    try {
      dbManager = new DatabaseManager();
      const dbPath = path3.join(folderPath, "ortoni-data-history.sqlite");
      await dbManager.initialize(dbPath);
      runId = await dbManager.saveTestRun();
      if (typeof runId === "number") {
        await dbManager.saveTestResults(runId, allResults);
        console.info(
          `Ortoni Report: Saved ${allResults.length} results to DB (runId=${runId}).`
        );
      } else {
        console.warn(
          "Ortoni Report: Failed to create test run in DB; proceeding without saving results."
        );
      }
    } catch (err) {
      console.error(
        "Ortoni Report: Error while saving history to DB. Proceeding without DB:",
        err
      );
      dbManager = void 0;
      runId = void 0;
    }
  } else {
    console.info(
      "Ortoni Report: Skipping history save (saveHistory=false). (Typical for CI runs)"
    );
  }
  const htmlGenerator = new HTMLGenerator(
    { ...mergedUserConfig || {}, meta: mergedUserMeta?.meta },
    dbManager
  );
  const finalReportData = await htmlGenerator.generateFinalReport(
    // filteredResults: typically filter out skipped for display (keeps existing behavior)
    allResults.filter((r) => r.status !== "skipped"),
    totalDuration,
    allResults,
    projectSet
    // pass Set<string> as original generateFinalReport expects
  );
  const fileManager = new FileManager(folderPath);
  const outputFileName = options.file || "ortoni-report.html";
  const outputPath = fileManager.writeReportFile(
    outputFileName,
    finalReportData
  );
  console.log(`\u2705 Final merged report generated at ${await outputPath}`);
  console.log(`\u2705 Shards merged: ${sortedFiles.length}`);
  console.log(`\u2705 Tests per shard:`, shardCounts);
  console.log(`\u2705 Total tests merged ${allResults.length}`);
}

// src/utils/expressServer.ts
var import_express = __toESM(require("express"));
var import_path3 = __toESM(require("path"));
var import_child_process = require("child_process");
function startReportServer(reportFolder, reportFilename, port = 2004, open2) {
  const app = (0, import_express.default)();
  app.use(import_express.default.static(reportFolder, { index: false }));
  app.get("/", (_req, res) => {
    try {
      res.sendFile(import_path3.default.resolve(reportFolder, reportFilename));
    } catch (error) {
      console.error("Ortoni Report: Error sending report file:", error);
      res.status(500).send("Error loading report");
    }
  });
  try {
    const server = app.listen(port, () => {
      console.log(
        `Server is running at http://localhost:${port} 
Press Ctrl+C to stop.`
      );
      if (open2 === "always" || open2 === "on-failure") {
        try {
          openBrowser(`http://localhost:${port}`);
        } catch (error) {
          console.error("Ortoni Report: Error opening browser:", error);
        }
      }
    });
    server.on("error", (error) => {
      if (error.code === "EADDRINUSE") {
        console.error(
          `Ortoni Report: Port ${port} is already in use. Trying a different port...`
        );
      } else {
        console.error("Ortoni Report: Server error:", error);
      }
    });
  } catch (error) {
    console.error("Ortoni Report: Error starting the server:", error);
  }
}
function openBrowser(url) {
  const platform = process.platform;
  let command;
  try {
    if (platform === "win32") {
      command = "cmd";
      (0, import_child_process.spawn)(command, ["/c", "start", url]);
    } else if (platform === "darwin") {
      command = "open";
      (0, import_child_process.spawn)(command, [url]);
    } else {
      command = "xdg-open";
      (0, import_child_process.spawn)(command, [url]);
    }
  } catch (error) {
    console.error("Ortoni Report: Error opening the browser:", error);
  }
}

// src/cli.ts
import_commander.program.version("4.0.1").description("Ortoni Report - CLI");
import_commander.program.command("show-report").description("Open Ortoni Report").option(
  "-d, --dir <path>",
  "Path to the folder containing the report",
  "ortoni-report"
).option(
  "-f, --file <filename>",
  "Name of the report file",
  "ortoni-report.html"
).option("-p, --port <port>", "Port to run the server", "2004").action((options) => {
  const projectRoot = process.cwd();
  const folderPath = path5.resolve(projectRoot, options.dir);
  const filePath = path5.resolve(folderPath, options.file);
  const port = parseInt(options.port) || 2004;
  if (!fs4.existsSync(filePath)) {
    console.error(
      `\u274C Error: The file "${filePath}" does not exist in "${folderPath}".`
    );
    process.exit(1);
  }
  startReportServer(folderPath, path5.basename(filePath), port, "always");
});
import_commander.program.command("merge-report").description("Merge sharded reports into one final report").option(
  "-d, --dir <path>",
  "Path to the folder containing shard files",
  "ortoni-report"
).option("-f, --file <filename>", "Output report file", "ortoni-report.html").action(async (options) => {
  await mergeAllData({
    dir: options.dir,
    file: options.file,
    saveHistory: false
  });
});
import_commander.program.parse(process.argv);
